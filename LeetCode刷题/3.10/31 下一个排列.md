实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须原地修改，只允许使用额外常数空间。

    以下是一些例子，输入位于左侧列，其相应输出位于右侧列。

    1,2,3 → 1,3,2  
    3,2,1 → 1,2,3  
    1,1,5 → 1,5,1

## 方法一：

算法思想：

1. 我们希望下一个数比当前数大，这样才满足“下一个排列”的定义。因此只需要**将后面的大数与前面的小数交换**，就能得到一个更大的数。比如 123456，将 5 和 6 交换就能得到一个更大的数 123465。

2. 我们还希望**下一个数增加的幅度尽可能的小**，这样才满足“下一个排列与当前排列紧邻“的要求。为了满足这个要求，我们需要：
    1. 在尽可能**靠右的低位**进行交换，需要**从后向前查找**。
   
    2. 将一个**尽可能小的大数**与前面的小数交换。比如 123465，下一个排列应该把 5 和 4 交换而不是把 6 和 4 交换。
   
    3. 将大数换到前面后，需要**将大数后面的所有数重置为升序，升序排列就是最小的排列**。以 123465 为例：首先按照上一步，交换 5 和 4，得到 123564；然后需要将 5 之后的数重置为升序，得到 123546。显然 123546 比 123564 更小，123546 就是 123465 的下一个排列。

算法过程：

1. 后向前查找第一个相邻升序的元素对 (i,j)，满足 A[i] < A[j]。此时 [j,end) 必然是**降序**；
2. 在 [j,end) 从后向前查找第一个满足 A[i] < A[k] 的 k；
3. 将 A[i] 与 A[k] 交换；
4. 可以断定这时 [j,end) 必然是**降序**，逆置 [j,end)，使其升序；
5. 如果在步骤 1 找不到符合的相邻元素对，说明当前 [begin,end) 为一个降序顺序，则直接跳到步骤 4。


```javascript
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var nextPermutation = function(nums) {
    let i = nums.length - 2;
    while (i >= 0 && nums[i] >= nums[i + 1]) i--; // 找到第一对nums[i] < nums[i + 1]
    // 如果有 i 满足情况
    if (i >= 0) {
        let j = nums.length - 1;
        while (j >= 0 && nums[i] >= nums[j]) j--; // 找到第一个大于 nums[i] 的数 nums[j]
        swap(nums, i, j); // 交换nums[i]和nums[j]
    }

    reserve(nums, i + 1, nums.length - 1); // 从 i+1 开始，之后的数一定是倒序排列！
};

var swap = function(nums, i, j) {
    var temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
};

var reserve = function(nums, start, end){
    while (start < end) {
        swap(nums, start, end);
        start++;
        end--;
    }
};
```