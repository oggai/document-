「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。前五项如下：

    1. 1
    2. 11
    3. 21
    4. 1211
    5. 111221

1 被读作  "one 1"  ("一个一") , 即 11。  
11 被读作 "two 1s" ("两个一"）, 即 21。  
21 被读作 "one 2",  "one 1" （"一个二" ,  "一个一") , 即 1211。

给定一个正整数 n（1 ≤ n ≤ 30），输出外观数列的第 n 项。

注意：整数序列中的每一项将表示为一个字符串。

## 方法一：正则表达式

```js
/**
 * @param {number} n
 * @return {string}
 */
var countAndSay = function (n) {
    let prev = '1';
    for (let i = 1; i < n; i++) {
        prev = prev.replace(/(\d)\1*/g, item => `${item.length}${item[0]}`);
    }
    return prev;

    // ---------------------------------------------------------------------------
    // prev.replace(/(\d)\1*/g, item => `${item.length}${item[0]}`)
    // 
    // 正则表达式 /(\d)\1*/g
    // \d 表示匹配整数；
    // ()\1 中的小括号"()"是代表分组的意思，如果后面出现\1 则是代表与第一个小括号中要匹配的内容相同；
    // * 表示匹配0次以上；
    // /g 表示匹配全局变量；
    // 所以表达式的意思是：匹配连续0次以上的数字。
    // 举个例子：111221 => '(1)(1)(1)', '(2)(2)', '(1)' => 312211
};
```

## 方法二：遍历法

```js
/**
 * @param {number} n
 * @return {string}
 */
var countAndSay = function(n) {
    let num = '1';
    // 考虑边界:求第n项序列只需求出n-1项即可，所以这里边界是i < n
    // 另num = '1' 已是第一项，所以i = 1
    for (let i = 1; i < n; i++) {
        let str = '';
        let count = 1;
        for (let j = 0; j < num.length; j++) { // 考虑边界
            if (num[j] === num[j + 1]) {
                count++;
            }
            else {
                str += count + num[j]; // 利用''进行强制转换，表达式为字符串相加，妙啊！
                count = 1;
            }
        }
        num = str; // 每次循环后都要把结果赋值给下一次的序列
    }
    return num;
};
```