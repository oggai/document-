给定两个二进制字符串，返回他们的和（用二进制表示）。

输入为非空字符串且只包含数字 1 和 0。

示例 1:

    输入: a = "11", b = "1"
    输出: "100"

示例 2:

    输入: a = "1010", b = "1011"
    输出: "10101"

## 方法一：逐位计算

```js
/**
 * @param {string} a
 * @param {string} b
 * @return {string}
 */
var addBinary = function(a, b) {
    let result = ''; // 记录结果
    let temp = 0; // 记录进位
    for (let i = a.length - 1, j = b.length - 1; i >= 0 || j >= 0; i--, j--) {
        let sum = temp;
        sum += (i >= 0 ? parseInt(a[i]) : 0); // 判断下标i 是否存在值，若不存在则填0
        sum += (j >= 0 ? parseInt(b[j]) : 0); // 判断下标j 是否存在值，若不存在则填0
        result += (sum % 2);
        // 对sum取模，即取 1 or 0，将结果保存在result中
        // 这一步可以通过位运算异或 ^ 实现
        temp = Math.floor(sum / 2);
        // 取进位，并在下一轮直接赋给sum 
        // 取进位可以通过右移一位实现
    }
    result += (temp === 1 ? 1 : ''); // 判断最后一次循环是否产生了进位
    return result.split('').reverse().join(''); // 每次result相加都是将结果加到字符串末尾，因此得出结果后应该翻转
};
```

### 知识点补充：

* n为非负数时，>> 1和/ 2的结果是一样的
  
* n为负数且还是偶数时，>> 1和/ 2的结果是一样的
  
* n为**负数且还是奇数**时，>> 1和/ 2的结果是不一样的
  
原因是奇数除二会发生截断现象。而>> 1和/ 2在n为负奇数时截断的反向不一样。

我们纵向比较一下：

-5 / 2 = -2，5 / 2 = 2。这表明**除二是向零取整**

-5 >> 1 = -3，5 >> 1 = 2。这表明**右移一位是向下取整**