## 《你不知道的JS》学习笔记

- **向上兼容和向下兼容**：

Forward Compatibility: 现在的程序可以兼容到未来程序的新特性

Backward Compatibility：新版程序的文件/语法可以在旧版程序上正常运行


- **LSH & RSH的区别：**

如果查找的目的是对变量进行赋值，那么就会使用 LHS 查询；如果目的是获取变量的值，就会使用 RHS 查询。


- **eval() & with() “欺骗”词法作用域**
```
function foo(str, a) {
  eval( str );   // 欺骗！
  console.log( a, b ); 
}
var b = 2;
foo( "var b = 3;", 1 ); // 1, 3
```
eval(..) 调用中的 "var b = 3;" ,这段代码会被当作本来就在那里一样来处理，此时b在函数内部声明，遮蔽了外部作用域的b.

```
function foo(obj) {
  with (obj) {        
  a = 2;
  }  
}
var o1 = {
  a: 3
};
var o2 = {
  b: 3
};

foo( o1 );
console.log( o1.a ); // 2
foo( o2 );
console.log( o2.a ); // undefined
console.log( a ); // 2——不好，a 被泄漏到全局作用域上了！
```
>with 声明实际上是根据你传递给它的对象凭空创建了一个全新的词法作用域。可以这样理解，当我们传递 o1 给 with 时，with 所声明的作用域是 o1，而这个作用域中含有一个同 o1.a 属性相符的标识符。但当我们将 o2 作为作用域时，其中并没有 a 标识符，因此进行了正常的 LHS 标识符查找,o2 的作用域、foo(..) 的作用域和全局作用域中都没有找到标识符 a，因此当 a＝2 执行时，自动创建了一个全局变量（因为是非严格模式）。